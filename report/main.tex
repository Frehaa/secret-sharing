\documentclass[a4paper,oneside,12pt,final]{article} 
\usepackage[utf8]{inputenc} 
\usepackage{graphics} 
\usepackage{listings}

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bm}
\usepackage{wrapfig}
\usepackage{float}
\usepackage[a4paper, marginparwidth=0pt]{geometry}
\usepackage{parskip}
\usepackage{lmodern}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[bottom]{footmisc}

\usepackage{xstring}


\graphicspath{./img/} 
\setlength{\parskip}{\baselineskip}% 
\setlength{\parindent}{0pt}% 
 
\begin{document} 

\input{title_page}
\newpage

\section{Introduction} 

The project is a simple interactive console application, which lets the user
simulate the parties of a verifiable secret sharing protocol. The user can
create a new secret sharing session, simulate parties reconstructing the secret,
simulate a party verifying their share, and change a party's share to see how
the results of the former commands would change.

\begin{figure}[h]
\label{fig:help}
\center
% \includegraphics[width=0.8\textwidth]{img/help-ss.png}
\caption{The applications help message which displays the available commands.}
\end{figure}

When initializing, the user can specify the secret, the number of parties needed
to reconstruct, the number of parties participating, as well as the random seed
used by the protocol.

\begin{figure}[h]
\label{fig:initialize-secret-sharing}
\center
% \includegraphics[width=0.8\textwidth]{img/initialize-print-ss.png}
\caption{A new secret sharing session established with the polynomial created, 
         the generator g, the parties shares, and the commitments.}
\end{figure}

The application was made using Haskell, a purely functional programming
language, using nothing but standard libraries, and implementing the necessary
cryptographic operations by hand. Haskell supports arbitrarily large integer
values almost seemlessly which makes creating polynomials of 1024 bits large
integers trivial. To generate the large primes used by the application I used
OpenSSL version 1.1.1.

For the next sections I will cover the theory used to implement the application,
relating it to the code where it makes sense, and discuss the performance of it.

\section{Theory}

The application was made using theory from the Shamir's Secret Sharing
scheme, as well as Feldman's scheme to make it verifiable. 

\subsection{Shamir Secret Sharing Polynomial}

Shamir's Secret Sharing scheme works by creating an n-degree polynomial,
using the secret as the intersect, to ensure that you need $n+1$ points from the
polynomial to reconstruct it. This way all parties can get their own point on
the polynomial as their share, and would have to group up with other parties to
have enough different points to reconstruct. This is an efficient way of
achieving k-out-of-n threshold secret sharing since every party only needs to
know a single point on the polynomial, which has the same size as the secret
itself.

The scheme works over a finite field $F$ from which the secret, $S$, is an
element of. After picking the secret we select $n$ random elements $a_1, a_2,
..., a_n$ in the field to create an n-degree polynomial. Using the secret as
intersect, and the other elements as the other coefficients in the polynomial
$p(x) = S + a_1x + a_2x^2 + ... + a_nx^n$.

I have implemented the scheme over the multiplicative group of integers modulo
q, and the polynomials are represented
as lists of integers. So using the secret as the intersect I create polynomials
as seen in figure~\pageref{fig:create-polynomial} by selecting $n$ numbers
randomly generated in the range between $1$ and $q-1$ where $q$ is a prime
number representing the group, implying $q-1$ is the order of the group.
\footnotemark

\newpage

\begin{figure}[h]
\label{fig:create-polynomial}
\begin{minted}[fontsize=\footnotesize]{haskell}
createPolynomial :: (RandomGen g) => Integer -> Int -> g -> Group -> Polynomial
createPolynomial intersect degree gen q =
    intersect : take degree (randomRs (1, q-1) gen)
\end{minted}
\caption{Code snippet for polynomial creation.}
\end{figure}

\footnotetext{A point of note here is that the numbers are selected slightly
differenly from how to select the secret, due to how Feldman's scheme works. But
I will come back to this when describing Feldman's scheme.}

\subsection{Party shares}

With a polynomial to represent the secret, the shares given to the parties can
then be calculated by evaluating the polynomial for values $i, i+1, i+2, ...$
and giving party $i$ the share $p(i)$, with $i > 0$. To make sure the shares
don't leak unnecessary information, the parties don't get $p(i)$, but a slighly
modified $p(i)\ mod\ q$ such that the shares themselves are quaranteed to be
part of the finite field. Here it is assumed that party $i$ knows the $i$
corresponding to themself.

\subsection{Reconstructing the Secret}

To reconstruct the secret the parties share their points on the polynomial to
recreate it, usually using Lagrange interpolation since it works in
finite fields.

Lagrange interpolation is calcuated as follows:

$L(x) := \Sigma_{j=0}^k y_j l_j(x)$

where 
$l_j(x) := \Pi_{0 \leq m \leq k, m \neq j}\frac{x - x_m}{x_j - x_m}$
and $k+1$ is the number of shares used to reconstruct. 

Since we aren't interested in the whole polynomial, but just the intersect, it
can be modified to be slightly more direct and efficient, by not including the
variable $x$ in the equation, and flipping the values in the denominator.

$l_j(x) := \Pi_{0 \leq m \leq k, m \neq j}\frac{x_m}{x_m - x_j}$

In the implementation I have used the Extended GCD algorithm to calculate 
the inverses of the elements needed to do the ``division`` in formula.

\subsection{Verifying the shares}

To make the scheme verifiable for the parties such that a party know their share
is valid, the Shamir Secret Sharing scheme is extended with additional
``commitments`` that the parties receive. This is the difference between Shamir
Secret Sharing scheme and Feldman's scheme. In Feldman's scheme we calculate an
additional $n+1$ values for our $n$-degree polynomial using a prime order
subgroup and a generator from this group. 

In this scheme the coefficients we picked for our polynomial have to be part of
this subgroup otherwise the scheme doesn't work. Feldman's scheme uses the fact
that addition in the exponent follows some slightly different rules, to give an
equation where party $i$ can verify that their share and the commitments match
up. 

Since the group has to be prime order and I'm working on the multiplicative
group of integers modulo $q$, the prime $q$ I'm using is a safe-prime, meaning
it has the form $q = 2 \cdot p + 1$ where both $p$ and $q$ are primes. To create
a prime order subgroup from this I take the quadratic residue modulo $q$ of all
elements in the multiplicative group, and this forms the subgroup. From this I
can pick a generator at random since every element in the subgroup except $1$ is
a generator. In the code this is implemented by selecting an element uniformly
at random from the multiplicative group and calculating the generator as the
quadratic residue modulo $q$ as seen in figure~\pageref{fig:select-generator}.

\begin{figure}[h]
\label{fig:select-generator}
\begin{minted}[fontsize=\footnotesize]{haskell}
selectGenerator :: (RandomGen g) => g -> Integer -> Integer
selectGenerator gen q = r^2 `mod` q
        where (r, _) = randomR (2, q-1) gen
\end{minted}
\caption{Code snippet for selecting generator for subgroup.}
\end{figure}



% ... 

When implemented over integers, at least in my application, this is
excrutiatingly slow for even small groups eg. 16 bit. 

\subsection{Primes}

The implementation uses more than a single prime. Dependin on the secret the
smallest working prime is picked. The primes used are of 8, 16, 32, 64, 128,
256, 512, and 1024 bits of length.

\section{Performance}

While good performance wasn't a goal of this project, and there are no messages
being transmitted over the network, it is still interesting to see how fast it
is to reconstruct and verify different configurations of the protocol.

\subsection{Reconstruct}

% Setup some test for different sized primes / number of parties

\subsection{Verify}

% Setup some test for different sized primes / number of parties
% Here the size of the primes will be very small, don't overdo

\end{document} 
